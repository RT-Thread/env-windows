<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Load and Store APIs &mdash; QEMU  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/qemu_32x32.png"/>
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/custom.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="The memory API" href="memory.html" />
    <link rel="prev" title="Bitwise operations" href="bitops.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #802400" >
            <a href="../index.html" class="icon icon-home"> QEMU
            <img src="../_static/qemu_128x128.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                7.2.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../about/index.html">About QEMU</a></li>
<li class="toctree-l1"><a class="reference internal" href="../system/index.html">System Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user/index.html">User Mode Emulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tools/index.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../interop/index.html">System Emulation Management and Interoperability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../specs/index.html">System Emulation Guest Hardware Specifications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Developer Information</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index-process.html">QEMU Community Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-build.html">QEMU Build and Test System</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index-api.html">Internal QEMU APIs</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="bitops.html">Bitwise operations</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Load and Store APIs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ld-p-and-st-p"><code class="docutils literal notranslate"><span class="pre">ld*_p</span> <span class="pre">and</span> <span class="pre">st*_p</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-ld-st-mmu"><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_mmu</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-ld-st-mmuidx-ra"><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_mmuidx_ra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-ld-st-data-ra"><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_data_ra</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-ld-st-data"><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_data</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-ld-code"><code class="docutils literal notranslate"><span class="pre">cpu_ld*_code</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#translator-ld"><code class="docutils literal notranslate"><span class="pre">translator_ld*</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#helper-ld-st-mmu"><code class="docutils literal notranslate"><span class="pre">helper_*_{ld,st}*_mmu</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-space"><code class="docutils literal notranslate"><span class="pre">address_space_*</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-space-write-rom"><code class="docutils literal notranslate"><span class="pre">address_space_write_rom</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#ld-st-phys"><code class="docutils literal notranslate"><span class="pre">{ld,st}*_phys</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-physical-memory"><code class="docutils literal notranslate"><span class="pre">cpu_physical_memory_*</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#cpu-memory-rw-debug"><code class="docutils literal notranslate"><span class="pre">cpu_memory_rw_debug</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-memory"><code class="docutils literal notranslate"><span class="pre">dma_memory_*</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pci-dma-and-ld-st-pci-dma"><code class="docutils literal notranslate"><span class="pre">pci_dma_*</span></code> and <code class="docutils literal notranslate"><span class="pre">{ld,st}*_pci_dma</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="memory.html">The memory API</a></li>
<li class="toctree-l3"><a class="reference internal" href="modules.html">QEMU modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="ui.html">QEMU UI subsystem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index-internals.html">Internal Subsystem Information</a></li>
<li class="toctree-l2"><a class="reference internal" href="index-tcg.html">TCG Emulation</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #802400" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QEMU</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Developer Information</a></li>
          <li class="breadcrumb-item"><a href="index-api.html">Internal QEMU APIs</a></li>
      <li class="breadcrumb-item active">Load and Store APIs</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://gitlab.com/qemu-project/qemu/blob/master/docs/devel/loads-stores.rst" class="fa fa-gitlab"> Edit on GitLab</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="load-and-store-apis">
<h1>Load and Store APIs<a class="headerlink" href="#load-and-store-apis" title="Permalink to this heading"></a></h1>
<p>QEMU internally has multiple families of functions for performing
loads and stores. This document attempts to enumerate them all
and indicate when to use them. It does not provide detailed
documentation of each API – for that you should look at the
documentation comments in the relevant header files.</p>
<section id="ld-p-and-st-p">
<h2><code class="docutils literal notranslate"><span class="pre">ld*_p</span> <span class="pre">and</span> <span class="pre">st*_p</span></code><a class="headerlink" href="#ld-p-and-st-p" title="Permalink to this heading"></a></h2>
<p>These functions operate on a host pointer, and should be used
when you already have a pointer into host memory (corresponding
to guest ram or a local buffer). They deal with doing accesses
with the desired endianness and with correctly handling
potentially unaligned pointer values.</p>
<p>Function names follow the pattern:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">ld{sign}{size}_{endian}_p(ptr)</span></code></p>
<p>store: <code class="docutils literal notranslate"><span class="pre">st{size}_{endian}_p(ptr,</span> <span class="pre">val)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> : signed</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">endian</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">he</span></code> : host endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">be</span></code> : big endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">le</span></code> : little endian</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">_{endian}</span></code> infix is omitted for target-endian accesses.</p>
<p>The target endian accessors are only available to source
files which are built per-target.</p>
<p>There are also functions which take the size as an argument:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">ldn{endian}_p(ptr,</span> <span class="pre">sz)</span></code></p>
<p>which performs an unsigned load of <code class="docutils literal notranslate"><span class="pre">sz</span></code> bytes from <code class="docutils literal notranslate"><span class="pre">ptr</span></code>
as an <code class="docutils literal notranslate"><span class="pre">{endian}</span></code> order value and returns it in a uint64_t.</p>
<p>store: <code class="docutils literal notranslate"><span class="pre">stn{endian}_p(ptr,</span> <span class="pre">sz,</span> <span class="pre">val)</span></code></p>
<p>which stores <code class="docutils literal notranslate"><span class="pre">val</span></code> to <code class="docutils literal notranslate"><span class="pre">ptr</span></code> as an <code class="docutils literal notranslate"><span class="pre">{endian}</span></code> order value
of size <code class="docutils literal notranslate"><span class="pre">sz</span></code> bytes.</p>
<dl class="simple">
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;ld[us]\?[bwlq]\(_[hbl]e\)\?_p\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;st[bwlq]\(_[hbl]e\)\?_p\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;ldn_\([hbl]e\)?_p\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;stn_\([hbl]e\)?_p\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="cpu-ld-st-mmu">
<h2><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_mmu</span></code><a class="headerlink" href="#cpu-ld-st-mmu" title="Permalink to this heading"></a></h2>
<p>These functions operate on a guest virtual address, plus a context
known as a “mmu index” which controls how that virtual address is
translated, plus a <code class="docutils literal notranslate"><span class="pre">MemOp</span></code> which contains alignment requirements
among other things.  The <code class="docutils literal notranslate"><span class="pre">MemOp</span></code> and mmu index are combined into
a single argument of type <code class="docutils literal notranslate"><span class="pre">MemOpIdx</span></code>.</p>
<p>The meaning of the indexes are target specific, but specifying a
particular index might be necessary if, for instance, the helper
requires a “always as non-privileged” access rather than the
default access for the current state of the guest CPU.</p>
<p>These functions may cause a guest CPU exception to be taken
(e.g. for an alignment fault or MMU fault) which will result in
guest CPU state being updated and control longjmp’ing out of the
function call.  They should therefore only be used in code that is
implementing emulation of the guest CPU.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">retaddr</span></code> parameter is used to control unwinding of the
guest CPU state in case of a guest CPU exception.  This is passed
to <code class="docutils literal notranslate"><span class="pre">cpu_restore_state()</span></code>.  Therefore the value should either be 0,
to indicate that the guest CPU state is already synchronized, or
the result of <code class="docutils literal notranslate"><span class="pre">GETPC()</span></code> from the top level <code class="docutils literal notranslate"><span class="pre">HELPER(foo)</span></code>
function, which is a return address into the generated code <a class="footnote-reference brackets" href="#gpc" id="id1">1</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="gpc"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Note that <code class="docutils literal notranslate"><span class="pre">GETPC()</span></code> should be used with great care: calling
it in other functions that are <em>not</em> the top level
<code class="docutils literal notranslate"><span class="pre">HELPER(foo)</span></code> will cause unexpected behavior. Instead, the
value of <code class="docutils literal notranslate"><span class="pre">GETPC()</span></code> should be read from the helper and passed
if needed to the functions that the helper calls.</p>
</dd>
</dl>
<p>Function names follow the pattern:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">cpu_ld{size}{end}_mmu(env,</span> <span class="pre">ptr,</span> <span class="pre">oi,</span> <span class="pre">retaddr)</span></code></p>
<p>store: <code class="docutils literal notranslate"><span class="pre">cpu_st{size}{end}_mmu(env,</span> <span class="pre">ptr,</span> <span class="pre">val,</span> <span class="pre">oi,</span> <span class="pre">retaddr)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for target endian, or 8 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_be</span></code> : big endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_le</span></code> : little endian</p></li>
</ul>
</dd>
<dt>Regexes for git grep:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_ld[bwlq](_[bl]e)\?_mmu\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_st[bwlq](_[bl]e)\?_mmu\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="cpu-ld-st-mmuidx-ra">
<h2><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_mmuidx_ra</span></code><a class="headerlink" href="#cpu-ld-st-mmuidx-ra" title="Permalink to this heading"></a></h2>
<p>These functions work like the <code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}_mmu</span></code> functions except
that the <code class="docutils literal notranslate"><span class="pre">mmuidx</span></code> parameter is not combined with a <code class="docutils literal notranslate"><span class="pre">MemOp</span></code>,
and therefore there is no required alignment supplied or enforced.</p>
<p>Function names follow the pattern:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">cpu_ld{sign}{size}{end}_mmuidx_ra(env,</span> <span class="pre">ptr,</span> <span class="pre">mmuidx,</span> <span class="pre">retaddr)</span></code></p>
<p>store: <code class="docutils literal notranslate"><span class="pre">cpu_st{size}{end}_mmuidx_ra(env,</span> <span class="pre">ptr,</span> <span class="pre">val,</span> <span class="pre">mmuidx,</span> <span class="pre">retaddr)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> : signed</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for target endian, or 8 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_be</span></code> : big endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_le</span></code> : little endian</p></li>
</ul>
</dd>
<dt>Regexes for git grep:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_ld[us]\?[bwlq](_[bl]e)\?_mmuidx_ra\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_st[bwlq](_[bl]e)\?_mmuidx_ra\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="cpu-ld-st-data-ra">
<h2><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_data_ra</span></code><a class="headerlink" href="#cpu-ld-st-data-ra" title="Permalink to this heading"></a></h2>
<p>These functions work like the <code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}_mmuidx_ra</span></code> functions
except that the <code class="docutils literal notranslate"><span class="pre">mmuidx</span></code> parameter is taken from the current mode
of the guest CPU, as determined by <code class="docutils literal notranslate"><span class="pre">cpu_mmu_index(env,</span> <span class="pre">false)</span></code>.</p>
<p>These are generally the preferred way to do accesses by guest
virtual address from helper functions, unless the access should
be performed with a context other than the default, or alignment
should be enforced for the access.</p>
<p>Function names follow the pattern:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">cpu_ld{sign}{size}{end}_data_ra(env,</span> <span class="pre">ptr,</span> <span class="pre">ra)</span></code></p>
<p>store: <code class="docutils literal notranslate"><span class="pre">cpu_st{size}{end}_data_ra(env,</span> <span class="pre">ptr,</span> <span class="pre">val,</span> <span class="pre">ra)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> : signed</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for target endian, or 8 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_be</span></code> : big endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_le</span></code> : little endian</p></li>
</ul>
</dd>
<dt>Regexes for git grep:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_ld[us]\?[bwlq](_[bl]e)\?_data_ra\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_st[bwlq](_[bl]e)\?_data_ra\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="cpu-ld-st-data">
<h2><code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}*_data</span></code><a class="headerlink" href="#cpu-ld-st-data" title="Permalink to this heading"></a></h2>
<p>These functions work like the <code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}_data_ra</span></code> functions
except that the <code class="docutils literal notranslate"><span class="pre">retaddr</span></code> parameter is 0, and thus does not
unwind guest CPU state.</p>
<p>This means they must only be used from helper functions where the
translator has saved all necessary CPU state.  These functions are
the right choice for calls made from hooks like the CPU <code class="docutils literal notranslate"><span class="pre">do_interrupt</span></code>
hook or when you know for certain that the translator had to save all
the CPU state anyway.</p>
<p>Function names follow the pattern:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">cpu_ld{sign}{size}{end}_data(env,</span> <span class="pre">ptr)</span></code></p>
<p>store: <code class="docutils literal notranslate"><span class="pre">cpu_st{size}{end}_data(env,</span> <span class="pre">ptr,</span> <span class="pre">val)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> : signed</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">end</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for target endian, or 8 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_be</span></code> : big endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">_le</span></code> : little endian</p></li>
</ul>
</dd>
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_ld[us]\?[bwlq](_[bl]e)\?_data\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_st[bwlq](_[bl]e)\?_data\+\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="cpu-ld-code">
<h2><code class="docutils literal notranslate"><span class="pre">cpu_ld*_code</span></code><a class="headerlink" href="#cpu-ld-code" title="Permalink to this heading"></a></h2>
<p>These functions perform a read for instruction execution.  The <code class="docutils literal notranslate"><span class="pre">mmuidx</span></code>
parameter is taken from the current mode of the guest CPU, as determined
by <code class="docutils literal notranslate"><span class="pre">cpu_mmu_index(env,</span> <span class="pre">true)</span></code>.  The <code class="docutils literal notranslate"><span class="pre">retaddr</span></code> parameter is 0, and
thus does not unwind guest CPU state, because CPU state is always
synchronized while translating instructions.  Any guest CPU exception
that is raised will indicate an instruction execution fault rather than
a data read fault.</p>
<p>In general these functions should not be used directly during translation.
There are wrapper functions that are to be used which also take care of
plugins for tracing.</p>
<p>Function names follow the pattern:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">cpu_ld{sign}{size}_code(env,</span> <span class="pre">ptr)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> : signed</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt>Regexes for git grep:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_ld[us]\?[bwlq]_code\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="translator-ld">
<h2><code class="docutils literal notranslate"><span class="pre">translator_ld*</span></code><a class="headerlink" href="#translator-ld" title="Permalink to this heading"></a></h2>
<p>These functions are a wrapper for <code class="docutils literal notranslate"><span class="pre">cpu_ld*_code</span></code> which also perform
any actions required by any tracing plugins.  They are only to be
called during the translator callback <code class="docutils literal notranslate"><span class="pre">translate_insn</span></code>.</p>
<p>There is a set of functions ending in <code class="docutils literal notranslate"><span class="pre">_swap</span></code> which, if the parameter
is true, returns the value in the endianness that is the reverse of
the guest native endianness, as determined by <code class="docutils literal notranslate"><span class="pre">TARGET_BIG_ENDIAN</span></code>.</p>
<p>Function names follow the pattern:</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">translator_ld{sign}{size}(env,</span> <span class="pre">ptr)</span></code></p>
<p>swap: <code class="docutils literal notranslate"><span class="pre">translator_ld{sign}{size}_swap(env,</span> <span class="pre">ptr,</span> <span class="pre">swap)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> : signed</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;translator_ld[us]\?[bwlq]\(_swap\)\?\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="helper-ld-st-mmu">
<h2><code class="docutils literal notranslate"><span class="pre">helper_*_{ld,st}*_mmu</span></code><a class="headerlink" href="#helper-ld-st-mmu" title="Permalink to this heading"></a></h2>
<p>These functions are intended primarily to be called by the code
generated by the TCG backend. They may also be called by target
CPU helper function code. Like the <code class="docutils literal notranslate"><span class="pre">cpu_{ld,st}_mmuidx_ra</span></code> functions
they perform accesses by guest virtual address, with a given <code class="docutils literal notranslate"><span class="pre">mmuidx</span></code>.</p>
<p>These functions specify an <code class="docutils literal notranslate"><span class="pre">opindex</span></code> parameter which encodes
(among other things) the mmu index to use for the access.  This parameter
should be created by calling <code class="docutils literal notranslate"><span class="pre">make_memop_idx()</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">retaddr</span></code> parameter should be the result of GETPC() called directly
from the top level HELPER(foo) function (or 0 if no guest CPU state
unwinding is required).</p>
<p><strong>TODO</strong> The names of these functions are a bit odd for historical
reasons because they were originally expected to be called only from
within generated code. We should rename them to bring them more in
line with the other memory access functions. The explicit endianness
is the only feature they have beyond <code class="docutils literal notranslate"><span class="pre">*_mmuidx_ra</span></code>.</p>
<p>load: <code class="docutils literal notranslate"><span class="pre">helper_{endian}_ld{sign}{size}_mmu(env,</span> <span class="pre">addr,</span> <span class="pre">opindex,</span> <span class="pre">retaddr)</span></code></p>
<p>store: <code class="docutils literal notranslate"><span class="pre">helper_{endian}_st{size}_mmu(env,</span> <span class="pre">addr,</span> <span class="pre">val,</span> <span class="pre">opindex,</span> <span class="pre">retaddr)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">s</span></code> : signed</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">endian</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">le</span></code> : little endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">be</span></code> : big endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ret</span></code> : target endianness</p></li>
</ul>
</dd>
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;helper_\(le\|be\|ret\)_ld[us]\?[bwlq]_mmu\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;helper_\(le\|be\|ret\)_st[bwlq]_mmu\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="address-space">
<h2><code class="docutils literal notranslate"><span class="pre">address_space_*</span></code><a class="headerlink" href="#address-space" title="Permalink to this heading"></a></h2>
<p>These functions are the primary ones to use when emulating CPU
or device memory accesses. They take an AddressSpace, which is the
way QEMU defines the view of memory that a device or CPU has.
(They generally correspond to being the “master” end of a hardware bus
or bus fabric.)</p>
<p>Each CPU has an AddressSpace. Some kinds of CPU have more than
one AddressSpace (for instance Arm guest CPUs have an AddressSpace
for the Secure world and one for NonSecure if they implement TrustZone).
Devices which can do DMA-type operations should generally have an
AddressSpace. There is also a “system address space” which typically
has all the devices and memory that all CPUs can see. (Some older
device models use the “system address space” rather than properly
modelling that they have an AddressSpace of their own.)</p>
<p>Functions are provided for doing byte-buffer reads and writes,
and also for doing one-data-item loads and stores.</p>
<p>In all cases the caller provides a MemTxAttrs to specify bus
transaction attributes, and can check whether the memory transaction
succeeded using a MemTxResult return code.</p>
<p><code class="docutils literal notranslate"><span class="pre">address_space_read(address_space,</span> <span class="pre">addr,</span> <span class="pre">attrs,</span> <span class="pre">buf,</span> <span class="pre">len)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">address_space_write(address_space,</span> <span class="pre">addr,</span> <span class="pre">attrs,</span> <span class="pre">buf,</span> <span class="pre">len)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">address_space_rw(address_space,</span> <span class="pre">addr,</span> <span class="pre">attrs,</span> <span class="pre">buf,</span> <span class="pre">len,</span> <span class="pre">is_write)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">address_space_ld{sign}{size}_{endian}(address_space,</span> <span class="pre">addr,</span> <span class="pre">attrs,</span> <span class="pre">txresult)</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">address_space_st{size}_{endian}(address_space,</span> <span class="pre">addr,</span> <span class="pre">val,</span> <span class="pre">attrs,</span> <span class="pre">txresult)</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
</ul>
</dd>
</dl>
<p>(No signed load operations are provided.)</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">endian</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">le</span></code> : little endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">be</span></code> : big endian</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">_{endian}</span></code> suffix is omitted for byte accesses.</p>
<dl class="simple">
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;address_space_\(read\|write\|rw\)\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;address_space_ldu\?[bwql]\(_[lb]e\)\?\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;address_space_st[bwql]\(_[lb]e\)\?\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="address-space-write-rom">
<h2><code class="docutils literal notranslate"><span class="pre">address_space_write_rom</span></code><a class="headerlink" href="#address-space-write-rom" title="Permalink to this heading"></a></h2>
<p>This function performs a write by physical address like
<code class="docutils literal notranslate"><span class="pre">address_space_write</span></code>, except that if the write is to a ROM then
the ROM contents will be modified, even though a write by the guest
CPU to the ROM would be ignored. This is used for non-guest writes
like writes from the gdb debug stub or initial loading of ROM contents.</p>
<p>Note that portions of the write which attempt to write data to a
device will be silently ignored – only real RAM and ROM will
be written to.</p>
<dl class="simple">
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">address_space_write_rom</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="ld-st-phys">
<h2><code class="docutils literal notranslate"><span class="pre">{ld,st}*_phys</span></code><a class="headerlink" href="#ld-st-phys" title="Permalink to this heading"></a></h2>
<p>These are functions which are identical to
<code class="docutils literal notranslate"><span class="pre">address_space_{ld,st}*</span></code>, except that they always pass
<code class="docutils literal notranslate"><span class="pre">MEMTXATTRS_UNSPECIFIED</span></code> for the transaction attributes, and ignore
whether the transaction succeeded or failed.</p>
<p>The fact that they ignore whether the transaction succeeded means
they should not be used in new code, unless you know for certain
that your code will only be used in a context where the CPU or
device doing the access has no way to report such an error.</p>
<p><code class="docutils literal notranslate"><span class="pre">load:</span> <span class="pre">ld{sign}{size}_{endian}_phys</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">store:</span> <span class="pre">st{size}_{endian}_phys</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
</ul>
</dd>
</dl>
<p>(No signed load operations are provided.)</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">endian</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">le</span></code> : little endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">be</span></code> : big endian</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">_{endian}_</span></code> infix is omitted for byte accesses.</p>
<dl class="simple">
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;ldu\?[bwlq]\(_[bl]e\)\?_phys\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;st[bwlq]\(_[bl]e\)\?_phys\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="cpu-physical-memory">
<h2><code class="docutils literal notranslate"><span class="pre">cpu_physical_memory_*</span></code><a class="headerlink" href="#cpu-physical-memory" title="Permalink to this heading"></a></h2>
<p>These are convenience functions which are identical to
<code class="docutils literal notranslate"><span class="pre">address_space_*</span></code> but operate specifically on the system address space,
always pass a <code class="docutils literal notranslate"><span class="pre">MEMTXATTRS_UNSPECIFIED</span></code> set of memory attributes and
ignore whether the memory transaction succeeded or failed.
For new code they are better avoided:</p>
<ul class="simple">
<li><p>there is likely to be behaviour you need to model correctly for a
failed read or write operation</p></li>
<li><p>a device should usually perform operations on its own AddressSpace
rather than using the system address space</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">cpu_physical_memory_read</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">cpu_physical_memory_write</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">cpu_physical_memory_rw</span></code></p>
<dl class="simple">
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;cpu_physical_memory_\(read\|write\|rw\)\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="cpu-memory-rw-debug">
<h2><code class="docutils literal notranslate"><span class="pre">cpu_memory_rw_debug</span></code><a class="headerlink" href="#cpu-memory-rw-debug" title="Permalink to this heading"></a></h2>
<p>Access CPU memory by virtual address for debug purposes.</p>
<p>This function is intended for use by the GDB stub and similar code.
It takes a virtual address, converts it to a physical address via
an MMU lookup using the current settings of the specified CPU,
and then performs the access (using <code class="docutils literal notranslate"><span class="pre">address_space_rw</span></code> for
reads or <code class="docutils literal notranslate"><span class="pre">cpu_physical_memory_write_rom</span></code> for writes).
This means that if the access is a write to a ROM then this
function will modify the contents (whereas a normal guest CPU access
would ignore the write attempt).</p>
<p><code class="docutils literal notranslate"><span class="pre">cpu_memory_rw_debug</span></code></p>
</section>
<section id="dma-memory">
<h2><code class="docutils literal notranslate"><span class="pre">dma_memory_*</span></code><a class="headerlink" href="#dma-memory" title="Permalink to this heading"></a></h2>
<p>These behave like <code class="docutils literal notranslate"><span class="pre">address_space_*</span></code>, except that they perform a DMA
barrier operation first.</p>
<p><strong>TODO</strong>: We should provide guidance on when you need the DMA
barrier operation and when it’s OK to use <code class="docutils literal notranslate"><span class="pre">address_space_*</span></code>, and
make sure our existing code is doing things correctly.</p>
<p><code class="docutils literal notranslate"><span class="pre">dma_memory_read</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">dma_memory_write</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">dma_memory_rw</span></code></p>
<dl class="simple">
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;dma_memory_\(read\|write\|rw\)\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;ldu\?[bwlq]\(_[bl]e\)\?_dma\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;st[bwlq]\(_[bl]e\)\?_dma\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
<section id="pci-dma-and-ld-st-pci-dma">
<h2><code class="docutils literal notranslate"><span class="pre">pci_dma_*</span></code> and <code class="docutils literal notranslate"><span class="pre">{ld,st}*_pci_dma</span></code><a class="headerlink" href="#pci-dma-and-ld-st-pci-dma" title="Permalink to this heading"></a></h2>
<p>These functions are specifically for PCI device models which need to
perform accesses where the PCI device is a bus master. You pass them a
<code class="docutils literal notranslate"><span class="pre">PCIDevice</span> <span class="pre">*</span></code> and they will do <code class="docutils literal notranslate"><span class="pre">dma_memory_*</span></code> operations on the
correct address space for that device.</p>
<p><code class="docutils literal notranslate"><span class="pre">pci_dma_read</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">pci_dma_write</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">pci_dma_rw</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">load:</span> <span class="pre">ld{sign}{size}_{endian}_pci_dma</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">store:</span> <span class="pre">st{size}_{endian}_pci_dma</span></code></p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">sign</span></code></dt><dd><ul class="simple">
<li><p>(empty) : for 32 or 64 bit sizes</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">u</span></code> : unsigned</p></li>
</ul>
</dd>
</dl>
<p>(No signed load operations are provided.)</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">size</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code> : 8 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w</span></code> : 16 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">l</span></code> : 32 bits</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">q</span></code> : 64 bits</p></li>
</ul>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">endian</span></code></dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">le</span></code> : little endian</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">be</span></code> : big endian</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">_{endian}_</span></code> infix is omitted for byte accesses.</p>
<dl class="simple">
<dt>Regexes for git grep</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;pci_dma_\(read\|write\|rw\)\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;ldu\?[bwlq]\(_[bl]e\)\?_pci_dma\&gt;</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">\&lt;st[bwlq]\(_[bl]e\)\?_pci_dma\&gt;</span></code></p></li>
</ul>
</dd>
</dl>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="bitops.html" class="btn btn-neutral float-left" title="Bitwise operations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="memory.html" class="btn btn-neutral float-right" title="The memory API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, The QEMU Project Developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
  

<!-- Empty para to force a blank line after "Built with Sphinx ..." -->
<p></p>

<p>This documentation is for QEMU version 7.2.0.</p>


<p><a href="../about/license.html">QEMU and this manual are released under the
GNU General Public License, version 2.</a></p>

 


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>